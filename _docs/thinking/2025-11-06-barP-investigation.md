# 2025-11-06 bar_P 調査メモ

- `fill_bar_P` の multibranch 逆伝播を追跡した。`get_bp_h_multi_sm` が参照する `bar_Pm[i, l]` と `bar_Pm1[i, l]` は、`fill_bar_Pm` / `fill_bar_Pm1` で更新される値で、いずれも **`j > l`** を条件に `bar_P[i, j]` を畳み込んでいる。したがって `bar_P[h, l]` が必要とする `bar_P[i, j]` は常にスパン `j - i ≥ (h - i) + (l - h) + 1 ≥ d + 4` を満たす（`i + 1 < h - 1` の条件より）。`d = l - h` だから、依存先のスパンは必ず現在処理中の `d` より大きく、`lax.scan` の降順更新と整合しており直接的な巡回参照は発生しない。
- 具体例: `h = 4, l = 7 (d = 3)` の場合、`get_bp_h_multi_sm` で許される `i` は `1` のみ。ここで参照する `bar_Pm[1, 7]` は `j ≥ 8` の項を集約しており、`bar_P[1, 8]`（スパン 7）など **既に更新済みの対角線**に依存している。`bar_P[4, 7]` が `bar_P[1, 7]` や `bar_P[4, 7]` 自身へ直截に戻る道筋は存在しない。
- それでも `bar_P` が異常値（例: `bar_P[1,7] ≈ 3.29×10^2`）を取るのは、multibranch 逆伝播の係数が「実際には存在しない枝組み合わせ」まで拾っているためと推測される。`bar_Pm` 経由の項は `ML[1, l+1, j-1]` が 0 のとき打ち消されるが、`bar_Pm1` 側には `ML` 由来のゲーティングが無く、`bar_P[i, j]` が非ゼロなら距離 `j-l-1` に応じた指数重みだけで外側重みが流れ込む。マルチループを形成できない配列でも、長いスタック列が存在すると `bar_Pm1` が有意に膨らみ、結果として `bar_P` に大きな値が伝播する。
- 次の検証ポイント:
  - `bar_Pm1` を計算する際に、forward の `MB` / `ML` が満たしていた枝数制約をどう再現するか再確認する（現状は 1 枝テーブル相当のフィルタが欠けている）。
  - `get_bp_h_multi_sm` の係数が forward の `em.en_multi_unpaired` と `s_table` の掛け方と一致しているか、数式レベルで突合する。特に `s_table[h - i]` の適用タイミングが forward のスケーリングと同型かをチェックする。
- テスト出力では `bar_Pm` が最大でも `~5×10^-2` 程度に収まる一方、`bar_Pm1[3,4] ≈ 8.7×10^5` まで急増していた。当初は `bar_Pm1` から `bar_P` へ戻る経路が暴走の主因と疑ったが、`ML[1, :, :]` が全 0 の配列では `get_bp_h_multi_sm` が 0 になり、コメントアウトしても `bar_P` に変化が無いことを確認。つまり multibranch は現状のシーケンスでは無関与であり、問題は bulge / internal / stacking 系の回路に絞られる。
- 次の焦点: `psum_outer_bulges` / `psum_outer_internal_loops` / スタック項を Vienna 実装と突き合わせ、不要な寄与や条件抜けが無いか精査する。特に一般内部ループで `bar_OMM` を省略した影響がどこに出ているか確認する。
