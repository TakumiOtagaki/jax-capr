Inputs:
  n                      # sequence length
  xi[0..n]               # inside external partition (xi(n) = 1)
  P[0..n-1][0..n-1]      # inside paired partition; P[i][j]=0 if i>=j or disallowed
  M[0..2][0..n-1][0..n-1]# inside multibranch partitions, p in {0,1,2}
  # energy helpers (all return Boltzmann factors):
  BMc = exp(-β * M_c)            # multibranch close penalty
  BMp = exp(-β * M_p)            # multibranch branch penalty (per branch)
  BMU(len) = exp(-β * M_u * len) # multibranch unpaired penalty for 'len' nts
  F2_WEIGHT(i,j,h,l)             # = exp(-β * f2(i,j,h,l))  (bulge/internal/stack)
                                 # ここに OMM/端ミスマッチ/ダングル等 forward と同じモデルを入れる

Outputs:
  bar_xi[0..n], bar_P[0..n-1][0..n-1], bar_M[0..2][0..n-1][0..n-1]

Procedure:

1) 初期化
   bar_xi[:] = 0
   bar_P[:][:] = 0
   bar_M[:][:][:] = 0

   # 全体分配関数 Z = xi(0)。outside の入口は xi(0) だけなので:
   bar_xi[0] = 1

2) xi の outside 伝播（外部ループ）
   # forward: xi(i) = xi(i+1) + Σ_{j>i} P(i,j) * xi(j+1)
   for i in 0..n-1:
       # skip（i を外部未対合で消費）
       bar_xi[i+1] += bar_xi[i]

       # i からペア (i,j) を張る場合
       for j in (i+1)..(n-1):
           bar_P[i][j] += bar_xi[i] * xi[j+1]  # 子 P へ
           bar_xi[j+1] += bar_xi[i] * P[i][j]  # 右側の外部テーブルへ

3) P の outside（長い区間→短い区間の順）
   # 親 (i,j) から子に伝播：
   #  - multibranch: M(2, i+1, j-1) へ
   #  - internal/bulge/stack: すべての (h,l) (i<h<l<j) へ
   for span in (n-1) downTo 1:
       for i in 0..(n-1-span):
           j = i + span
           if bar_P[i][j] == 0: continue

           # (a) multibranch の親寄与（P の式: + M(2, i+1, j-1) * BMc * BMp）
           if i+1 < j:
               bar_M[2][i+1][j-1] += bar_P[i][j] * BMc * BMp

           # (b) internal/bulge/stack の親寄与
           #    全ての内側 (h,l) に加える（必要なら総長 C を制限）
           for h in (i+1)..(j-2):
               for l in (h+1)..(j-1):
                   # optional speed-up: if (h-i-1)+(j-l-1) > C: continue
                   bar_P[h][l] += bar_P[i][j] * F2_WEIGHT(i,j,h,l)

4) M の outside（長い区間→短い区間の順）
   # forward: M(p,i,j) = M(p,i+1,j) * BMU(1) + Σ_{k} P(i,k)*BMp*M(p-1,k+1,j)
   for span in (n-1) downTo 1:
       for i in 0..(n-1-span):
           j = i + span
           for p in {0,1,2}:
               if bar_M[p][i][j] == 0: continue

               # (a) 未対合 1 塩基を消費
               if i+1 <= j:
                   bar_M[p][i+1][j] += bar_M[p][i][j] * BMU(1)

               # (b) 枝を 1 本追加（分岐）: 親 M(p,i,j) -> 子 P(i,k) と 子 M(p-1, k+1,j)
               childp = max(0, p-1)
               for k in (i+1)..(j-1):
                   bar_P[i][k]              += bar_M[p][i][j] * BMp * M[childp][k+1][j]
                   bar_M[childp][k+1][j]    += bar_M[p][i][j] * BMp * P[i][k]

5) （必要なら）ペア確率の計算
   Z = xi[0]
   for i<j:
       pair_prob[i][j] = (P[i][j] * bar_P[i][j]) / Z