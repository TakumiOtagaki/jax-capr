いいね、では一気にいきます。まずは「読みやすくて絶対に正しい順序」を優先した素直な outside（非ベクトル化）擬似コード、そのあとに **O(n³)** を意識したベクトル化版です。テーブルはあなたのノートの定義（(\xi, P, M) と (\bar\xi,\bar P,\bar M)）に完全準拠、内部ループの **OMM（outer/terminal mismatch）** は `F2_WEIGHT` の中に含めて forward と同じモデルで評価する想定です。

---

# A) 素直な outside（非ベクトル化）pseudocode

> 目的：forward（inside）で得た `xi(i)`, `P(i,j)`, `M(p,i,j)` を **与え**として、
> outside テーブル `bar_xi(i)`, `bar_P(i,j)`, `bar_M(p,i,j)` を計算し、最後に (Z=\xi(0)) と (p(i,j))（必要ならループ文脈確率）を取り出せる状態にします。

```txt
Inputs:
  n                      # sequence length
  xi[0..n]               # inside external partition (xi(n) = 1)
  P[0..n-1][0..n-1]      # inside paired partition; P[i][j]=0 if i>=j or disallowed
  M[0..2][0..n-1][0..n-1]# inside multibranch partitions, p in {0,1,2}
  # energy helpers (all return Boltzmann factors):
  BMc = exp(-β * M_c)            # multibranch close penalty
  BMp = exp(-β * M_p)            # multibranch branch penalty (per branch)
  BMU(len) = exp(-β * M_u * len) # multibranch unpaired penalty for 'len' nts
  F2_WEIGHT(i,j,h,l)             # = exp(-β * f2(i,j,h,l))  (bulge/internal/stack)
                                 # ここに OMM/端ミスマッチ/ダングル等 forward と同じモデルを入れる

Outputs:
  bar_xi[0..n], bar_P[0..n-1][0..n-1], bar_M[0..2][0..n-1][0..n-1]

Procedure:

1) 初期化
   bar_xi[:] = 0
   bar_P[:][:] = 0
   bar_M[:][:][:] = 0

   # 全体分配関数 Z = xi(0)。outside の入口は xi(0) だけなので:
   bar_xi[0] = 1

2) xi の outside 伝播（外部ループ）
   # forward: xi(i) = xi(i+1) + Σ_{j>i} P(i,j) * xi(j+1)
   for i in 0..n-1:
       # skip（i を外部未対合で消費）
       bar_xi[i+1] += bar_xi[i]

       # i からペア (i,j) を張る場合
       for j in (i+1)..(n-1):
           bar_P[i][j] += bar_xi[i] * xi[j+1]  # 子 P へ
           bar_xi[j+1] += bar_xi[i] * P[i][j]  # 右側の外部テーブルへ

3) P の outside（長い区間→短い区間の順）
   # 親 (i,j) から子に伝播：
   #  - multibranch: M(2, i+1, j-1) へ
   #  - internal/bulge/stack: すべての (h,l) (i<h<l<j) へ
   for span in (n-1) downTo 1:
       for i in 0..(n-1-span):
           j = i + span
           if bar_P[i][j] == 0: continue

           # (a) multibranch の親寄与（P の式: + M(2, i+1, j-1) * BMc * BMp）
           if i+1 < j:
               bar_M[2][i+1][j-1] += bar_P[i][j] * BMc * BMp

           # (b) internal/bulge/stack の親寄与
           #    全ての内側 (h,l) に加える（必要なら総長 C を制限）
           for h in (i+1)..(j-2):
               for l in (h+1)..(j-1):
                   # optional speed-up: if (h-i-1)+(j-l-1) > C: continue
                   bar_P[h][l] += bar_P[i][j] * F2_WEIGHT(i,j,h,l)

4) M の outside（長い区間→短い区間の順）
   # forward: M(p,i,j) = M(p,i+1,j) * BMU(1) + Σ_{k} P(i,k)*BMp*M(p-1,k+1,j)
   for span in (n-1) downTo 1:
       for i in 0..(n-1-span):
           j = i + span
           for p in {0,1,2}:
               if bar_M[p][i][j] == 0: continue

               # (a) 未対合 1 塩基を消費
               if i+1 <= j:
                   bar_M[p][i+1][j] += bar_M[p][i][j] * BMU(1)

               # (b) 枝を 1 本追加（分岐）: 親 M(p,i,j) -> 子 P(i,k) と 子 M(p-1, k+1,j)
               childp = max(0, p-1)
               for k in (i+1)..(j-1):
                   bar_P[i][k]              += bar_M[p][i][j] * BMp * M[childp][k+1][j]
                   bar_M[childp][k+1][j]    += bar_M[p][i][j] * BMp * P[i][k]

5) （必要なら）ペア確率の計算
   Z = xi[0]
   for i<j:
       pair_prob[i][j] = (P[i][j] * bar_P[i][j]) / Z
```

* これで **正当性 > 速度** を優先した outside が完成。
* 実運用では (3)(b) の内部ループ総和を **総長 C（例: 30）** で切って (O(n^3)) に落とします。`F2_WEIGHT` に OMM/末端ミスマッチ等を必ず含めるのがポイント。

---

# B) ベクトル化／高速化つき outside 擬似コード（O(n³)）

> アイデア：
>
> 1. multibranch → あなたのノートの (\bar P^{m}, \bar P^{m1}) を使って **i と j の畳み込みを分離**。
> 2. internal → **(u,v) = (h-i-1, j-l-1)** の“短い”範囲（総長 ≤ C）にバケツ分けして、同一 (u,v) を **対角単位で一括**更新。
> 3. ループ順序は **長い区間→短い区間**。各長さ ℓ を処理するとき、ℓ より長い親からの寄与はすでに `bar_P, bar_M` に入っているため、子の更新が因果に沿います。

```txt
Helper (precompute once):
  # 1) multibranch 内部で使う M(1, a, b) を、区間長だけのテンソルに射影できるならそうする
  #    そうでない場合も、そのまま index で参照すれば良い
  # 2) internal 用に、許容する (u,v) の集合 U = {(u,v) | u>=0, v>=0, u+v <= C} を列挙
  #    F2_TABLE[u][v][i][j] = F2_WEIGHT(i,j, i+1+u, j-1-v) を事前計算 or on-the-fly で評価
  #    ※ OMM/末端ミスマッチは F2_WEIGHT に含める

Procedure (vectorized):

1) 初期化（Aと同じ）
   bar_xi[0] = 1; 他は 0

2) xi outside（Aと同じだが、行列演算でまとめても良い）
   for i in 0..n-1:
       bar_xi[i+1] += bar_xi[i]
       # vectorized over j
       J = range(i+1, n)
       bar_P[i, J]      += bar_xi[i] * xi[J+1]         # 1×|J|
       bar_xi[J+1]      += bar_xi[i] * P[i, J]         # 1×|J|

3) 長さループ（ℓ = j-i）
   for ℓ in (n-1) downTo 1:

       # ---------- (I) M の outside：一括更新 ----------
       # a) 未対合1塩基消費：bar_M[p, i+1, j] += bar_M[p, i, j] * BMU(1)
       #    -> これは "左に1シフト" + スカラー乗算 でベクトル化可
       for p in {0,1,2}:
           # take slice of span ℓ: i in [0..n-1-ℓ], j=i+ℓ
           S = bar_M[p, 0: n-ℓ, 0: n-ℓ]  aligned so that S[i] corresponds to (i, i+ℓ)
           bar_M[p, 1: n-ℓ, 1: n-ℓ+ℓ?] += S * BMU(1)   # 実装では (i+1, j) インデクシングで

       # b) 分岐：Σ_k を batched matmul で
       #    bar_P[i,k] += bar_M[p,i,j]*BMp*M[max(0,p-1),k+1,j]
       #    bar_M[p-1,k+1,j] += bar_M[p,i,j]*BMp*P[i,k]
       for p in {0,1,2}:
           childp = max(0, p-1)

           # k を軸にまとめる（各 (i,j) 固定で k を全走査）:
           #   Left tensor  L[i,k]   = P[i,k]
           #   Right tensor R[k,j]   = M[childp, k+1, j]
           #   Weight tensor W[i,j]  = bar_M[p,i,j] * BMp
           # すると:
           #   bar_M[childp, k+1, j] += Σ_i W[i,j] * L[i,k]        (i で縮約)
           #   bar_P[i,k]            += Σ_j W[i,j] * R[k,j]        (j で縮約)
           # 実装は tensordot / batched_gemm で OK

           W = bar_M[p, :, :] * BMp
           # 更新1: bar_P  ←  (over j) contraction of W[i,j] with R[k,j]
           bar_P[:, :] += contract_over_j(W,  M[childp, shift_kp1, :])  # 具体実装は後述のコメント参照
           # 更新2: bar_M(childp) ← (over i) contraction of W[i,j] with L[i,k]
           bar_M[childp, :, :] += contract_over_i(W,  P[:, :])

       # ---------- (II) P の outside：一括更新 ----------
       # (a) multibranch 親→子 M(2,i+1,j-1) へ（これは単純）
       bar_M[2, 1: n-ℓ, ℓ-1-shift?] += bar_P[0: n-ℓ, ℓ] * (BMc * BMp)
       # 実装では (i,j=i+ℓ) の列ベクトルを 1 つ左内側へ配置して加算

       # (b) internal/bulge/stack 親→子 P(h,l) へ
       #     (u,v) バケツごとの対角ベクトル化
       for each (u,v) in U:    # u+v ≤ C
           # 親 (i,j) の対角 ℓ に対して、子は h=i+1+u, l=j-1-v
           # つまり、親の全 i を1本のベクトルにすると、子 (h,l) も同じ長さのベクトルで index が一致
           I = 0 .. (n-1-ℓ)                 # 全 i
           H = I + 1 + u
           L = (I + ℓ) - 1 - v
           # 子がちゃんと区間内に収まるものだけマスク
           mask = (H < L)

           w = F2_TABLE[u][v][ I , I+ℓ ]    # or F2_WEIGHT(i,j,h,l) をベクトルで
           bar_P[ H[mask], L[mask] ] += bar_P[ I[mask], I[mask]+ℓ ] * w[mask]

       # (c) multibranch (i,j) → 子 P(h,l) は、O(n³) 版では
       #     あなたのノートの和を使う：barP^m, barP^m1 を右端 l 固定で集計し、左端 h ごとに前置和
       #     ここで処理するのは "右端 = l = i+ℓ の対角" で、親は必ずそれより長いので因果順は保たれる

       l = (all right-ends on this diagonal)             # l = i+ℓ
       # まず、固定 l について i を軸に:
       #   barP_m[i]  = Σ_{j>l} bar_P[i,j] * M(1, l+1, j-1)
       #   barP_m1[i] = Σ_{j>l} bar_P[i,j] * BMU(j-l-1)
       barP_m  = reduce_sum_over_j_gt_l( bar_P[:, :]*M1_tensor(l), axis=j )
       barP_m1 = reduce_sum_over_j_gt_l( bar_P[:, :]*BMU_tensor(l), axis=j )

       # つぎに、各 h<l に対して i<h の前置和を一括で取る（行列積 or prefix-scan）
       #   add = BMc*BMp * [  M(1, i+1, h-1) @ barP_m1[i]  +  {M(1, i+1, h-1)+BMU(h-i-1)} @ barP_m[i]  ]
       # これは h を縦ベクトル、i を横ベクトルとして 2 回の GEMV で計算できる
       ADD1[h] =  Σ_{i<h}  M1_left(i,h) * barP_m1[i]
       ADD2[h] =  Σ_{i<h} (M1_left(i,h) + BMU(h-i-1)) * barP_m[i]
       bar_P[h, l] += (BMc * BMp) * (ADD1[h] + ADD2[h])
```

### ベクトル化の実装メモ

* **`contract_over_j` / `contract_over_i`** は、(i,j) の 2 次元テンソルと、(k,j) あるいは (i,k) の 2 次元テンソルとの縮約。JAX なら `jax.lax.dot_general` / `einsum('ij,kj->ik', W, R)` 等で書けます。
* **(u,v) バケツ**は (u+v\le C) のみ回すので (\mathcal{O}(C^2 n))。各ステップは対角ベクトルの Hadamard 積＋加算なので速い。
* **multibranch の (\bar P^m, \bar P^{m1})** は、右端 l ごとに **列方向の reduce-sum** を 1 回行い（`j>l` の部分だけをマスク）、左端 h ごとの **prefix-scan** を 2 回（`M1_left` と `M1_left + BMU`）行えば良いです。`M1_left(i,h)=M(1,i+1,h-1)` は (i<h の下三角) 行列として持ち、GEMV でまとめて更新できます。

---

## 仕上げのチェック（実装時に必ず回す簡易検証）

1. **確率の整合**
   (\forall i:\ \sum_{j\ne i} p(i,j) + p(i,\text{unpaired}) = 1)
   ここで (p(i,j) = P(i,j)\bar P(i,j)/Z)、未対合は外部 (E) と多分岐内部 (M) の未対合を合計。
2. **総和の整合**
   (\sum_{i<j} p(i,j)) が forward 実装の出す総和と一致。
3. **対称性**
   内部ループの OMM を含む `F2_WEIGHT` が ((i,j,h,l)\leftrightarrow(i,j,h,l)) の期待対称性（u,v の入れ替えに応じた）を満たす。

---

## 重要ポイントの再掲

* **OMM は outside で“別テーブル”は不要**。`F2_WEIGHT` の中で forward と**同じ**モデルを掛ければ OK。入れ忘れるとモデル不一致になります。
* multibranch の外側寄与は、

  1. 親 (P(i,j)\to\bar M(2,i+1,j-1))（直接）
  2. 親 (P(i,j)\to\bar P(h,l))（(\bar P^m,\bar P^{m1}) の畳み込み）
     の **二経路**。上の B 版では (2) を O(n³) で入れています。
* 反復順序は「**長い区間→短い区間**」。これさえ守れば outside の因果関係は自然に満たせます。

---

必要なら、この擬似コードをそのまま `jax` で動く関数スケルトン（`lax.scan`/`vmap` 版）に整えてお渡しします。
